#!/bin/sh
# vim: set fileencoding=utf-8:
#
# convtags is a bidirectional converter beetween DokuWiki and AsciiDoc
# formatted text files. See http://slint.fr/misc/convtags/README
#
# Copyright (C) Didier Spaier 2015, Paris, France
# Copyright (C) Jakub Jirutka 2017, Prague, Czech Republic
# All rights reserved.
#
# Redistribution and use of this software, with or without modification, is
# permitted provided that the following conditions be met:
#
# 1. Redistribution of this script must retain the above copyright
#    notice, this list of conditions and the following disclaimer.
#
#  THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
#  IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
#  OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
#  IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
#  INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
#  NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
#  DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
#  THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
#  (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
#  OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
#
#                           Overview
# ----------------------------------------------------------------------
#   Settings 
#   User interface
# ------------------ Line tagged @part1@ -------------------------------
#   Conversion DokuWiki to AsciiDoc (part 1)
# ------------------ Line tagged @part2@ -------------------------------
#   Conversion DokuWiki to AsciiDoc (part 2)
# ------------------ Line tagged @EOF@  --------------------------------
#   Information about support
# ----------------------------------------------------------------------
# 
VERSION=1
DATE=04/10/2015
#
# Configuration
# =============
# 
# We provide no configuration file. To create one, just type:
#   convtags config > [configuration file]
# then edit your configuration file to customize the settings.
# 
# To use your configuration file, set it as CONFIGFILE in the command
# line, for instance:
#   CONFIGFILE=~/convtagsrc convtags ...
#
# CONFIGFILE is set to a null string by default.
#
CONFIGFILE=${CONFIGFILE:-}
#
# DKROOT is the absolute URL of the DokuWiki remote server.
# Setting it allows you to replace the internal links in a DokuWiki page
# by corresponding external links in the converted AsciiDoc page, thus
# allowing to check them.
# When converting back to DokuWiki the absolute URLs are kept.
#
DKROOT=${DKROOT:-http://docs.slackware.com}
#
# DKIMAGES is the absolute URL of the images' sub-directory of the
# DokuWiki installation.
# Setting it allows you to display in the converted AsciiDoc page the
# images linked as internal in the DokuWiki pages, and optionally to
# keep the full URL of the images in the converted back DokuWiki pages.
#
DKIMAGES=${DKIMAGES:-http://docs.slackware.com/_media}
#
# IMAGEEXTS is a comma separated list of file extensions (without a dot) that
# are acceptable for image::[] directive. Other media will be converted just
# to link:[].
#
IMAGEEXTS=${IMAGEEXTS:-gif,jpg,jpeg,png,svg}
#
# QUOTESTYPE specifies what type of quotation marks use in Asciidoc output.
# Options:
#   asciidoctor - '`single`', "`double`"
#   plain       - 'single', "double"
#   unicode-en  - â€˜singleâ€™, â€˜doubleâ€™
#   unicode-cs  - â€šsingleâ€˜, â€ždoubleâ€œ
#
QUOTESTYPE=${QUOTESTYPE:-asciidoctor}
#
# SED is a sed command to use.
#
SED=${SED:-sed}
#
# End of configuration

set -eu

# Gather the settings in the configuration file if provided by the user.
# The settings in that file override those above.
if [ "$CONFIGFILE" ]; then
	if [ -f "$CONFIGFILE" ]; then
		. "$CONFIGFILE"
	else
		echo "The configuration file $CONFIGFILE was not found." >&2
		exit 1
	fi
fi

# Insure that the paths will end up with one trailing <solidus>.
DKROOT=${DKROOT%/}/
DKIMAGES=${DKIMAGES%/}/

IMAGE_FILE_PATT="\\\\.\\\\($(echo "$IMAGEEXTS" | $SED 's/,/\\\\|/g')\\\\)"

case "$QUOTESTYPE" in
	asciidoctor) LS_QUOTE="'\`" RS_QUOTE="\`'" LD_QUOTE='"`' RD_QUOTE='`"';;
	unicode-en) LS_QUOTE='â€˜' RS_QUOTE='â€™' LD_QUOTE='â€œ' RD_QUOTE='â€';;
	unicode-cs) LS_QUOTE='â€š' RS_QUOTE='â€˜' LD_QUOTE='â€ž' RD_QUOTE='â€œ';;
	*) LS_QUOTE="'" RS_QUOTE="'" LD_QUOTE='"' RD_QUOTE='"';;
esac

help() {
	cat >&2 <<-EOF
	  convtag: converter from DokuWiki to AsciiDoc

	  Usage: convtags da [DokuWiki file] [AsciiiDoc file]
	         convtags config   # information about configuration settings
	         convtags settings # display current settings
	         convtags support  # how to get support

	  Visit http://slint.fr/misc/convtags to know more and get the current
	  release.

	  This is convtags version $VERSION released on $DATE.
	EOF
	exit 1
}

dw2adoc() {
	asciidoc_tmp=$(mktemp)
	cleaned_tmp=$(mktemp)

	# We remove also all zero width spaces U+200B, writing one after [
	# on line below.
	< "$1" $SED "s/[â€‹]//g" > "$cleaned_tmp"
	$SED -e "$(< "$0" $SED -n "/^#@part1@/,/^#@part2@/p")" "$cleaned_tmp" > "$asciidoc_tmp"
	rm -f "$cleaned_tmp"

	DKROOT="$(echo ${DKROOT%/}/ | $SED s.//..)"
	DKIMAGES="$(echo ${DKIMAGES%/}/ | $SED s.//..)"

	$SED -n -e "$(< "$0" $SED -n "/^#@part2@/,/^#@EOF@/p" \
		| $SED "sDKROOT$DKROOTg" \
		| $SED "sDKIMAGES$DKIMAGESg" \
		| $SED "sLS_QUOTE$LS_QUOTEg" \
		| $SED "sRS_QUOTE$RS_QUOTEg" \
		| $SED "sLD_QUOTE$LD_QUOTEg" \
		| $SED "sRD_QUOTE$RD_QUOTEg" \
		| $SED "sIMAGE_FILE_PATT$IMAGE_FILE_PATTg")" \
		"$asciidoc_tmp" > "$2"

	DKROOT="$(echo ${DKROOT%/}/ | $SED s..//.)"
	DKIMAGES="$(echo ${DKIMAGES%/}/ | $SED s..//.)"

	rm -f "$asciidoc_tmp"
}

case "${1:-}" in
	settings)
		cat <<-EOF
		  Current settings:
		  CONFIGFILE=$CONFIGFILE
		  DKROOT=$DKROOT
		  DKIMAGES=$DKIMAGES
		  IMAGEEXTS=$IMAGEEXTS
		  QUOTESTYPE=$QUOTESTYPE
		  SED=$SED
  
		  You are using convtags version $VERSION released on $DATE
  
		  Type "convtags config" to know more.
		EOF
	;;
	config)
		< "$0" $SED -n '/^# Configuration/,/^# End of configuration/p' \
			| $SED '1s/^/\n/' \
			| $SED '$d' \
			| $SED 's/^#/ /'
	;;
	support)
		< "$0" $SED -n '/^# Support/,/^# End of support/p' \
			| $SED '1s/^/\n/' \
			| $SED '$d' \
			| $SED 's/^#/ /'
	;;
	da)
		[ $# -eq 3 ] || help
		dw2adoc "$2" "$3"
	;;
	*)
		help
	;;
esac

exit

#@part1@ ---------------------------------------------------------------
#
# Rationale
# =========
#
# sed is basically a line editor, that has limited abilities to process a
# block of consecutive lines, partly because a POSIX compliant sed program
# is not required to be able to store more than 8192 bytes in the pattern
# and hold spaces.
#
# But the proper processing instructions of a line depends on its context
# set by the previous line(s).
#
# To hand over this context from a line to the next one(s), we store it at
# the end of each cycle in the hold space, represented by a character
# string that we call the "baton" by analogy with a relay race, separated
# from the input data by a U+04 or  character.
#
# At the beginning of each cycle we append the baton to the new input line
# gathered in the pattern space.
#
# U+04 represents the last hex digits of the Unicode code point of
# <end of text> in UTF-8.
#
# Here is the list of the control codes and other indicators used,
# represented in the same way.
#
# Char.  Corresponding mark or meaning
# 01  begins a <code> ... </code> block
# 02  begins a <file> ... </file> block
# 03  begins a <nowiki> ... </nowiki> area
# 04  separates the baton from the input data
# 05  begins a preformatted block
# 06  list item that can continue on the next line
# 07  %% preceding the text not to be parsed (as <nowiki>)
# 08  %% following the text not to be parsed (as </nowiki>)
# 0E  ends a <code>... or <file>... block or of a code block whose
#         lines begin with two spaces
# 10  ends a <nowiki> ... </nowiki>
# 11  %% in case of an odd number of this pattern in a line
# 12  Local tentative replacement
# 12  Local tentative replacement
# 14  indicates a blank line so we know that the previous was blank
# 15  separator, replaced by a zero width space U+200B at end of script
# 16  marks the beginning of the remaining part of the line where we
#         still have to look for "no formatting" areas.
# 1A  begins a <note[^<]*> ... </note> area
# 1C  tentatively replaces /^  / in a preformatted block.
# We have to deal with DokuWiki' syntax, that:
# _allows to put the opening or closing tag of a block anywhere on a line
# _has several ways of marking the beginning and the end of a code block
#  and "no formatting" area
# _requests a specific usage of the "forced line break" and location of
#  opening and closing tags of a code block to indicate that the next
#  line(s) should be indented as part of a list item, cf.
#  https://www.dokuwiki.org/faq:lists
#
# We will standardize the formatting of the Code blocks, recording in the
# baton the initial kind when it opens to allow finding the corresponding
# closing tag or line.
#
# Similarly we will standardize the formatting of the "no formatting" areas
# remembering the opening tag's kind in the baton.
#
# In this first part, we put each opening or closing tag of a block of text
# on its own line, to ease further processing, somehow "verticalizing" the
# input text.
#
# Initialization
# ==============
# Append an empty baton to the first input line
1 s/$//
# Append the baton, gathered from the hold space, to following input lines.
2,$	{
		G
		s/\n//
}
# If the baton included a  or a  or a  indicator, move
# it at the beginning of the pattern space so we know that we are in a
# delimited  block.
// {s///;s/^//}
// {s///;s/^//}
#
# No WiKi ?
# =========
#
# But in a Code block we find and mark the "nowiki" areas.
#
/[]/ !{
	s/^//
	s/<nowiki>//g
	s@</nowiki>@@g
	s/%%//g
	:noformat
	# Convert the next %% (was ) if not preceded by <nowiki> (was ).
	/[^]*[^]*/ {
		# then find the next ex 
		s/\([^]*[^]*\)/\1/
		# move the  after the  closing tag.
		s/\([^]*\)/\1/
		# Convert back the   and  inside that area.
		:a
		s/\(.*\)\(.*\)/\1<nowiki>\2/
		s@\(.*\)\(.*\)@\1</nowiki>\2@
		ta
		s///
		t noformat
	}
	# Convert the next <nowiki> (was ) if not preceded by %% (was ).
	/[^]*[^]*/ {
		s/\([^]*\)/\1/
		:b
		s/\(.*\)\(.*\)/\1%%\2/
		tb
		s///
		t noformat
	}
	# standardize: all nowiki areas will become  ...  from now on.
	s/\([^]*\)/\1/g
	s/\([^]*\)/\1/g
	# Convert back the remaining tags.
	s//%%/g
	s//%%/g
	s//<nowiki>/g
	s@@</nowiki>@g
	s///g
	s///g
	s///
}
:begin
#
# Lists
# =====
# We know that we are not in the Code block if no ,  or  begins
# the pattern space. If after two spaces we see a "*" or a "-' this is a
# list item, not the beginning of a preformatted block.
#
# Dokuwki detects a list item even with an odd number of leading spaces,
# and no space between the last * or - and the text. The patterns are
# adapted accordingly. 
# We need to cope with differences between DokuWiki and AsciiDoc:
# _ In AsciiDoc, a list item is only recognized as such if preceded by an
#   empty line or by a "line continuation" \n+\n indicator (and there can
#   be any number of empty  lines between two list items). Else the line
#   that begins with "*" is  just appended to the previous one.
# _ In DokuWiki an empty line ends a list, then the next list item will
#   be of level 1 regardless of the number of spaces before "*" or "-"
#
/[]/ !{
	 # If the line  is not a list item, remove the "list item" indicator
	 # from the baton, but if it begins with </code> or </file> as that
	 # doesn't close the item.
	/^\(   *\)\{1,5\}[*][^*]/ !{
		/^\(   *\)\{1,5\}-[^-]/ !{
			\.^</code>. !{
				\.^</file>. !{
					s///
				}
			}
		}
	}
	/^\(   *\)\{1,5\}[*][^*]/ {
		# unordered lists
		s/^   \?\* \?/* /
		s/^     \?\* \?/** /
		s/^       \?\* \?/*** /
		s/^         \?\* \?/**** /
		s/^           \?\* \?/***** /
		# Insert a <newline> before this one if the previous was neither
		# empty nor a list item.
		// !{
			// !s/^/\n/
		}
		# Remove the line break that could end a list item.
		s/[\][\] *//
		# Mark the line as being part of a list item
		// !s///
	}
	/^\(   *\)\{1,5\}-[^-]/ {
		# ordered lists
		s/^   \?- \?/. /
		s/^     \?- \?/.. /
		s/^       \?- \?/... /
		s/^         \?- \?/.... /
		s/^           \?- \?/..... /
		# Insert a <newline> before this one if the previous was neither
		# empty nor a list item.
		// !{
			// !s/^/\n/
		}
		# Remove the line break that could end a list item.
		s/[\][\] *//
		# Mark the line as being part of a list item
		// !s///
	}
}
# A blank line interrupts a multiline list item.
/^/ s///
#
# Code blocks
# ===========
#
# Here "code block"  designate a block surrounded by <code ...> then
# </code> or by <file ...> then </file>: they have the same syntax in
# DokuWiki. We will convert these blocks in "literal blocks" in
# Asciidoc parlance.
#
# In DokuWiki syntax a code block that begins inside a line belonging to
# a list item is embedded in this list item.
# But in AsciiDoc a literal block shall begin and end with marks alone
# on their lines, and for such a block to be embedded in a list item that
# immediately precedes it these marks should be surrounded by lines
# including just a <plus> sign.
# So, as // indicates a list item:
# _ If //! we need a newline before and after <code[^>]*> and
#   </code> if they are not the first or the last word of the line resp.
# _ If // we need a line with just a <plus> before <code[^>]*>
#   and after <plus> and <code[^>]*> if they are not the first or the
#   last word respectively (a <code> that begins a line is not in a list
#   item)
#
# We process the tags only if they have not a  "Code block begins"
# indicator on their left, not followed by a "Code block ends" indicator.
# We insert a "Code block begins" indicator after the <code> tag only if
# this tag doesn't end the line as else the indicator in the baton suffice.
# We remove all spaces after </code>
# <code> ... </code> blocks
# We skip the <code> tags if preceded by %% or </nowiki>, not followed
# by another %% or </nowiki>
# <code> begins a Code block, but in a delimited block.
# 
# We wil convert separately the beginning of blocks with a "to be
# highlighted" source code.
#
# We perform here the first part of the conversion, that is isolate each
# tag on a line, the opening tag being preceded by a line with
# [source,<language>] in case of syntax highlighting.
# The replacement of the tags by lines containing just"----" will be made
# in the second part of the program.
#
# First if we have a pattern /^   */ we are in a preformatted block
# (not in a list, that would have been detected above). Then, skip the
# processing of code blocks.
/^   */b preformat
#
# In this loop we process all code blocks in an input line.
:codes
# Code blocks
# ===========
#
# outside a list item
# -------------------
#
# Closing tags
# We put the closing tags before the opening ones, else in
# case of a pattern like the following in a single line:
# ^</code> ... <code>$
# the <code> tag would not be converted. This case is unlikely outside
# a list items, but who knows?
#
// ! {
	# Do not allow a forced line break after a closing tag.
	s@^\(</code>\) *[\][\] *@\1@
	s@\([^]*</code>\) *[\][\] *@\1@
	s@^</code> *@</code>\n@
	# Begins a line.
	s@^</code>\([[:print:]]\)@</code>\n\1@
	# Ends a line
	s@\([^]*[[:print:]]\)</code> *@\1\n</code>@
	# Inside a line
	s@\([^]*[[:print:]]\)</code>\([[:print:]]\)@\1\n</code>\n\2@
}
// ! {
	# Do not allow a forced line break after a closing tag.
	s@^\(</file>\) *[\][\] *@\1@
	s@\([^]*</file>\) *[\][\] *@\1@
	s@^</file> *@</file>\n@
	# Begins a line.
	s@^</file>\([[:print:]]\)@</file>\n\1@
	# Ends a line
	s@\([^]*[[:print:]]\)</file> *@\1\n</file>@
	# Inside a line
	s@\([^]*[[:print:]]\)</file>\([[:print:]]\)@\1\n</file>\n\2@
}
#
# Opening tags
#
// !{
	/[][^]*<code>/ !{
		/[^]*<code>/ !{
			// ! {
				# If there are only spaces after the mark, discard them.
				s/<code> */<code>/
				# In its own line.
				s/^<code>/<code>/
				# Begins a line 
				s/^<code>\([[:print:]]\)/<code>\n\1/
				# Ends a line. If we are in a list item, it continues.
				s/<code> */\n<code>/
				# Inside a line.
				s/\([[:print:]]\)<code>\([[:print:]]\)/\1\n<code>\n\2/
			}
		}
	}
}
# Highlighted source code
# We don't convert the "download-able code snippet" feature, hence
# restrict what goes after "< code" to alphabetic characters.
#
// !{
	/[][^]*<code \([[:alpha:]]*\)>/ !{
		/[^]*<code \([[:alpha:]]*\)>/ !{
			// ! {
				s/<code [-.] *[^<]*>/<code txt>/g
				# Remove links to download-able code blocks
				s/<code \([[:alpha:]]*\) [^>]*>/<code \1>/
				# If there are only spaces after the mark, discard them.
				s/\(<code [[:alpha:]]*>\) */\1/
				# In its own line.
				s/^<code \([[:alpha:]]*\)>/[source,\1]\n<code>/
				# Begins a line 
				s/^<code \([[:alpha:]]*\)>\([[:print:]]\)/[source,\1]\n<code>\n\2/
				# Ends a line. If we are in a list item, it continues.
				s/<code \([[:alpha:]]*\)> */\n[source,\1]\n<code>/
				# Inside a line.
				s/\([[:print:]]\)<code \([[:alpha:]]*\)>\([[:print:]]\)/\1\n[source,\2]\n<code>\n\3/
			}
		}
	}
}
// !{
	/[][^]*<file>/ !{
		/[^]*<file>/ !{
			// ! {
				# If there are only spaces after the mark, discard them.
				s/<file> */<file>/
				# In its own line.
				s/^<file>/<file>/
				# Begins a line 
				s/^<file>\([[:print:]]\)/<file>\n\1/
				# Inside a line.
				s/\([[:print:]]\)<file>\([[:print:]]\)/\1\n<file>\n\2/
				# Ends a line. If we are in a list item, it continues.
				s/<file>/\n<file>/
			}
		}
	}
}
# Highlighted source code
# We don't convert the "download-able file snippet" feature, hence
# restrict what goes after "< file" to alphabetic characters.
// !{
	/[][^]*<file \([[:alpha:]]*\)>/ !{
		/[^]*<file \([[:alpha:]]*\)>/ !{
			// ! {
				s/<file [-.] *[^<]*>/<file txt>/g
				# Remove links to down-loadable code blocks
				s/<file \([[:alpha:]]*\) [^>]*>/<file \1>/
				# If there are only spaces after the mark, discard them.
				s/\(<file [[:alpha:]]*>\) */\1/
				# In its own line.
				s/^<file \([[:alpha:]]*\)>/[source,\1]\n<file>/
				# Begins a line 
				s/^<file \([[:alpha:]]*\)>\([[:print:]]\)/[source,\1]\n<file>\n\2/
				# Inside a line.
				s/\([[:print:]]\)<file \([[:alpha:]]*\)>\([[:print:]]\)/\1\n[source,\2]\n<file>\n\3/
				# Ends a line. If we are in a list item, it continues.
				s/<file \([[:alpha:]]*\)>/\n[source,\1]\n<file>/
			}
		}
	}
}
#
# Code blocks inside a list item
# ==============================
#
# Closing tags
#
# In this case we put the closing tags before the opening ones, else in
# case of a pattern like the following in a single line:
# ^</code> ... <code>$
# the <code> tag would not be converted.
#
// {
	# Do not allow a forced line break after a closing tag or at EOL
	s@^\(</code>\) *[\][\] *@\1@
	s@^\(</code>.*\)[\][\]@\1@
	s@\([^]*</code>\) *[\][\] *@\1@
	# In its own line
	s@^</code> *@</code>\n+@
	# Begins a line.
	s@^</code>\([[:print:]]\)@</code>\n+\n\1@
	# Ends a line
	s@\([^]*[[:print:]]\)</code> *@\1\n</code>\n+@
	# Inside a line
	s@\([^]*[[:print:]]\)</code>\([[:print:]]\)@\1\n</code>\n+\n\2@
}
// {
	# Do not allow a forced line break after a closing tag or at EOL.
	s@^\(</file>\) *[\][\] *@\1@
	s@^\(</file>.*\)[\][\]@\1@
	s@\([^]*</file>\) *[\][\] *@\1@
	# In its own line
	s@^</file> *@</file>\n+@
	# Begins a line.
	s@^</file>\([[:print:]]\)@</file>\n+\n\1@
	# Ends a line
	s@\([^]*[[:print:]]\)</file> *@\1\n</file>\n+@
	# Inside a line
	s@\([^]*[[:print:]]\)</file>\([[:print:]]\)@\1\n</file>\n+\n\2@
}
# opening tags
#
// !{
	/[][^]*<code>/ !{
		/[^]*<code>/ !{
			// {
				# If there are only spaces after the mark, discard them.
				s/<code> */<code>/
				# Inside a line.
				s/\([[:print:]]\)<code>\([[:print:]]\)/\1\n+\n<code>\n\2/
				# Ends a line. If we are in a list item, it continues.
				s/<code>/\n+\n<code>/
			}
		}
	}
}
# Highlighted source code
# We don't convert the "download-able code snippet" feature, hence
# restrict what goes after "< code" to alphabetic characters.
#
// !{
	/[][^]*<code \([[:alpha:]]*\)>/ !{
		/[^]*<code \([[:alpha:]]*\)>/ !{
			// {
				s/<code [-.] *[^<]*>/<code txt>/g
				# Remove links to download-able code blocks
				s/<code \([[:alpha:]]*\) [^>]*>/<code \1>/
				# If there are only spaces after the mark, discard them.
				s/\(<code [[:alpha:]]*>\) */\1/
				# Inside a line.
				s/\([[:print:]]\)<code \([[:alpha:]]*\)>\([[:print:]]\)/\1\n+\n[source,\2]\n<code>\n\3/
				# Ends a line. If we are in a list item, it continues.
				s/<code \([[:alpha:]]*\)>/\n+\n[source,\1]\n<code>/
			}
		}
	}
}
// !{
	/[][^]*<file>/ !{
		/[^]*<file>/ !{
			// {
				# If there are only spaces after the mark, discard them.
				s/<file> */<file>/
				s/^<file>\([[:print:]]\)/<file>\n\1/
				# Inside a line.
				s/\([[:print:]]\)<file>\([[:print:]]\)/\1\n+\n<file>\n\2/
				# Ends a line. If we are in a list item, it continues.
				s/<file>/\n+\n<file>/ # No need to insert a <newline> before?
			}
		}
	}
}
# Highlighted source code
# We don't convert the "download-able file snippet" feature, hence
# restrict what goes after "< file" to alphabetic characters.
// !{
	/[][^]*<file \([[:alpha:]]*\)>/ !{
		/[^]*<file \([[:alpha:]]*\)>/ !{
			// {
				s/<file [-.] *[^<]*>/<file txt>/g
				# Remove links to download-able code blocks
				s/<file \([[:alpha:]]*\) [^>]*>/<file \1>/
				# If there are only spaces after the mark, discard them.
				s/\(<file [[:alpha:]]*>\) */\1/
				# Inside a line.
				s/\([[:print:]]\)<file \([[:alpha:]]*\)>\([[:print:]]\)/\1\n+\n[source,\2]\n<file>\n\3/
				# Ends a line. If we are in a list item, it continues.
				s/<file \([[:alpha:]]*\)>/\n+\n[source,\1]\n<file>/
			}
		}
	}
}
t codes
# If   and we closed a Code block,  should be preceded by a "line
# continuation" indicator. We check that after all forced line breaks have
# been converted after the Code block.
// {
	/[^]*/ {
		/\n+/ !s//\n+/
	}
}
# 
// !{
	/\[source,[[:alpha:]]*]\n<code>/ {
		s/\[source,[[:alpha:]]*]\n<code>/\n&/
		b out
	}
	/\[source,[[:alpha:]]*]\n<file>/ {
		s/\[source,[[:alpha:]]*]\n<file>/\n&/
		b out
	}
	s/<code>/\n&/
	s/<file>/\n&/
}
:out
#
# Inside Code blocks, we escape "----" that ends an AsciiDoc Listing block.
# We precede it by a U+15  now to ease checking. We will replace it by
# a zero width space U+200B before printing the line.
/[]/ s/\([]\)\(-----\)/\1\2/
#
# Preformatted text
# =================
#
# Now we process preformatted blocks, already recognized as such.
# They are Code blocks made of lines beginning with two spaces.
:preformat
// {
	# Close a formatted block if the line doesn't begin with two spaces.
	/^  /  !{
		s///g
		s@[^]*@</code>\n&@
		# Print the line that ends the Code block.
		P
		# Delete it. We don't use the D command because we don't want to
		# append a new baton.
		s@</code>\n@@
		# Then process the remaining line
		b begin
	}
	# Else tentatively replace these spaces with U+1C 
	# that we will remove before printing.
	/^  /  s/  //
	# And inside this line "escape" the <code[^]]*> and </code> and
	# <file[^]]*> and </file> so they be not considered as such in the
	# second part.
	s@<code[^>]*>@<code[^>]*>@g
	s@</code>@<code>@g
	s@<file[^>]*>@<file[^>]*>@g
	s@</file>@<file>@g
}
#
# Preformatted text ?
# ===================
#
# Let's find the beginning of preformatted blocks of text.
# An input line beginning with two spaces and that is not in a list item
# nor part of a Code block begins a preformatted block.
# But if this input line contains no graphical character, then it begins
# such a block only if one of the following adjacent lines also begins with
# two spaces and includes a graphical character.
#
# To check that, in case the first line of the "could be" preformatted block
# contains only spaces, we fetch the next lines until we find a line that
# either does not begin with two spaces, or includes a graphical
# character in POSIX parlance.
# _If the line contains at least two spaces and nothing else, we fetch the
#  next line.
# _If the line does not begin with two spaces we begin a new cycle without
#  fetching a new input line: we didn not begin a preformatted block.
# _Else the line begins with two spaces and includes at least one graphical
#  character. Then we mark the line as preformatted and branch to the label
#  "preformat" that begins the processing of preformatted blocks.
# In all cases we remove the previous line after having fetched a new one.
#
# We insert an empty line before ^<code>, as a workaround against an
# AsciiDoc bug that wrongly converts e.g.
#
# ----
# Literal block 1
# ----
# <line of text>
# ----
# Literal block 2
# ----
# 
# in cases where <line of text> is very short like "to".
#
/[]/ !{
	/^   *[[:graph:]]/ {
		s/^/<code>\n/
		s/^<code>/\n&/
		P
		s/\n//
		P
		s/<code>\n//
		s///
		b preformat
	}
	/^   */ {
		:addline
		$ !N
		# If the next line contains at least two spaces and only that,
		# iterate.
		/[^\n]*\n  *$/ {
			s/\([^\n]*\)\(\n.*\)/\2\1/
			s/[^\n]*\n//
			b addline
		}
		# If the next line doesn't begin with two spaces, we are not in a
		# Code block. Then begin a new cycle without fetching a new line nor
		# appending another baton.
		/[^\n]*\n  / !{
			s/^  *//
			s/\([^\n]*\)\n\(.*\)/\2\1/
			s/[^\n]*\n//
			b begin
		}
		# Else the next line begins with two spaces but also includes other
		# characters so we actually began a preformatted block.
		# Then branch to the label that begins the processing of such blocks.
		# Swap the newline and the baton
		s/\([^\n]*\)\(.*\)/\2\1/
		# Remove the old line
		s/[^\n]*\n//
		# Insert a line with <code> before the new line
		s/^/<code>\n/
		s/^<code>/\n&/
		P
		s/\n//
		# Print then remove the line with <code>
		P
		s/<code>\n//
		# Only the new line remains in the pattern space
		# Mark the line as part of a preformatted block
		s///
		b preformat
	}
}
# A line beginning with ">" that is not in a delimited block is part of
# a an email-like quote. We will just replace > by U+2502 â”‚.
# But we also need to make sure that an empty line precedes a set of
# quoted lines.  We append forced line break to each line of the set to
# avoid that consecutive lines be merged by asciidoc.
/[]/ !{
	/^>/ !{
		/\([^>]*\)>\([^>]*\)/ {
			s/\([^>]*\)>\([^>]*\)/\1\2/
			s/^/\n/
		}
	}
	/^>/ {
		// !{
			s/^/\n/
			/[^>]*>[^>]*/ !s/^/\n/
		}
		s/^>>>>>>/â”‚â”‚â”‚â”‚â”‚â”‚/
		s/^>>>>>/â”‚â”‚â”‚â”‚â”‚/
		s/^>>>>/â”‚â”‚â”‚â”‚/
		s/^>>>/â”‚â”‚â”‚/
		s/^>>/â”‚â”‚/
		s/^>/â”‚/
		s/\n>>>>>>/â”‚â”‚â”‚â”‚â”‚â”‚/
		s/\n>>>>>/â”‚â”‚â”‚â”‚â”‚/
		s/\n>>>>/â”‚â”‚â”‚â”‚/
		s/\n>>>/â”‚â”‚â”‚/
		s/\n>>/â”‚â”‚/
		s/\n>/â”‚/
		s// +/
		/[^>]*>[^>]*/ !s//>/
	}
}
# Forced line break
# =================
#
# Line breaks after code blocks are already converted.
#
# Remove line breaks after </code> or </file>
s@</code> *[\][\] *@</code>@g
s@</file> *[\][\] *@</file>@g
#
# Inside a list item:
# _A line break at end of line will be removed.
# _Line continuation indicators will be converted.
# _If a forced line break has been converted a \n+ is appended unless
#  the line ends in <code[^>]*> or <file[^>]*>.
#
// {
	:ack
	/[\][\] */ s/[\][\] *//
	/ *[\][\]  */ {
		s/ *[\][\]  */\n+\n/
		/<code[^>]*>/ !{
			/<file[^>]*>/ !{  
				/\n+/ !s//\n+/
			}
		}
	}
	t ack
}
# // {
# 	:ack
# 	/[\][\] */ {
# 		s/[\][\] *//
# 			s///
# 	}
# 	/ *[\][\]  */ {
# 		s/ *[\][\]  */\n+\n/
# 		/<code[^>]*>* */ !{
# 			/<file[^>]*>* */ !s///
# 		}
# 	}
# 	t ack
# }
# Outside a list item :
# _A Line break that begins a line will be removed.
#_ A line break in a nowiki area will not be converted.
# _A line break in a Code or preformatted block will not be converted.
# _A line break inside a line will not be converted.
# _Line breaks inside tables will be processed in @part 2@.
# _All other line breaks will be converted, inside or at the end of line.
:linebr
/^[|^]/ !{
	// !{
		# No part of the line is in a Code block or nowiki area
		:linebr1
		/^[^]/ {
			s/^ *[\][\] *//
			s/[\][\] */ +/
			s/ *[\][\]  */ +\n/
		}
		# This part of the line follows a Code block
		/[^]*[\][\]/ {
			s/[\][\] */ +/
			s/ *[\][\]  */ +\n/
		}
		# This part of the line follows a nowiki area
		/[^]*[\][\]/ {
			s/[\][\] */ +/
			s/ *[\][\]  */ +\n/
		}
	}
}
t linebr
# Admonitions
# ===========
# This assume the usage of the Note plug-in of DokuWuki): the output file
# needs a plug-in to be correctly parsed in AsciiDoc then.
/[][^]*$/ !{
	// !{
		/<note[^<]*>/ {
			# On its own line: nothing to do yet.
			# Begins a line
			/^<note[^<]*>[^]/ {
				s/^<note[^<]*>/&\n/
				s/$//
			}
			# Inside a line.
			/[[:print:]]<note[^<]*>[[:print:]]/ {
				s/\([[:print:]]\)\(<note[^<]*>\)\([[:print:]]\)/\1\n\2\n\3/
				s/$//
			}
			# Ends a line.
			/[[:print:]]<note[^<]*>/ {
				s/\([[:print:]]\)\(<note[^<]*>\)/\1\n\2/
				s/$//
			}
		}
	}
}
/[][^]*$/ !{
	// !{
		\.</note>. {
			s@</note> *+@</note>@
			# On its own line: nothing to do yet.
			\.^</note>*. {
				s///
			}
			\.\n</note>*. {
				s///
			}
			# Begins a line.
			\.^</note>[^]. {
				s@^</note>@</note>\n@
				s///
			}
			# Inside a line.
			\.[[:print:]]</note>[[:print:]]. {
				s@\([[:print:]]\)</note>\([[:print:]]\)@\1\n</note>\n\2@
				s///
			}
			# Ends a line.
			\.[[:print:]]</note>*. {
				s@\([[:print:]]\)</note>@\1\n</note>@
				s///
			}
			s// +/
		}
	}
}
#
# If we find two consecutive patterns of "line continuation", remove one.
s@\n+\n\n+\n@\n+\n@g
# This would occur for instance if a line ends in:
# "you will have to convert it to a 'compat32' package: \\ <code>"
# and is part of a list item.
# We will insert a U+15  before patterns that would be parsed in
# AsciiDoc as explicitly numbered list items.
s/^[[:alnum:]]\+\./&/
s/^[ixvIXV]\+)/&/
# Replace U+15  by zero width space U+200B
s//â€‹/g
h
# The hold space content's is now identical to that of the pattern space. 
x
# Following changes are done in the hold space
# In case of a blank line we write U+14  in the baton if there wasn't
# one already so we will know that the next line has been preceded by a
# blank line.
/^/ {
	// !s/$//
}
/\n/ {
	/\n+/ !{
		// !s/$//
	}
}
# Else we just remove the  if any, but in case of a forced line break.
/^/ !{
	/ / !{
		/\n/ !s///
	}
}
// {
	/[^]*/ !s//&/
}
// {
	/[^]*/ !s//&/
}
s/.*//
x
s/.*//
s/[]//g
#
#@part2@ ---------------------------------------------------------------
#
# In the first part the markup of the input file has been "verticalized",
# i.e. each opening or closing tag of a Code or Admonition block is now
# alone in its line. This allows to print as-is the lines of a Code block,
# skipping all substitutions inside these lines.
#
# List of the control codes and other indicators used in this part:
#
# Char.  Corresponding mark or meaning.
# P 01  <code>
# P 02  <file>
# 03  <nowiki>
# I = 04  Separates the stack from the input data
# B 05  to mark characters that have a special meaning
# C 06  tentatively replaces "mono-spaced" '' =>  => ``
# 07  %% preceding the text not to be parsed (as <nowiki>)
# 08  %% following the text not to be parsed (as </nowiki>)
# 0B  left single quotation mark: ' => ^K => '`
# OC  right single quotation mark: ' => ^L => `'
# C 0E  left double quotation mark: " => ^N => "`
# 0F  right double quotation mark: " => ^O => `"
# 10  </nowiki>
# 11  various tentative replacements
# 12  tentatively replaces | n tables f no cell boundary, then escaped
#         as "\" once converted  
# 13  tentatively replaces | n tables f no cell boundary, then restored
#         as "^" once converted (no special meaning in AsciiDoc syntax)
# B 14  table row
# 15  [ then ++[++
# 16  indicates that a table cell have already been formatted
# 17  //
# 18  [[
# 19  ]]
# 1A  ] then ++]++
# 1D  tentative beginning and end of image:target[attributes)
# 1E  last line was /^\n$/
# 1F  ` constrained mono-spaced
1s/$//
# If we see a line with just a <plus> sign it is a list item continuation.
# _If the next is a heading, replace the <plus> with a <new line>
# _If the next is empty, delete the first with the <plus>
# _Else, print then delete the first.
/^+$/ {
	N
	/\n===*[^=]\+===*/ !{
		/\n$/ !{
			x
			s/$//
			x
			P
			D
		}
	}
	/\n===*[^=]\+===*/ {
		s/^+//
		P
	}
	/\n$/ s/+\n//
}
2,$	{
	G
	s/\n//
}
# Replace [[ with 18  and ]] with 19 
s/\[\[//g
s/\]]//g
# If we see the beginning of a Code block, we indicate that in the baton.
# Then we print the line and begin another cycle until we find a closing
# tag. Then we remove the Code block indicator from the baton, print the
# line and start a new cycle.
/[]/ !{
	/^\[source,[[:alpha:]]*\]/ b print
	/^\[verse]/ b print
	/^<code>/ {
		s///
		s/<code>/----/
		b print
	}
	/^<file>/ {
		s///
		s/<file>/----/
		b print
	}
}
# Escape existing  [<text>] that should not be parsed in AsciiDoc.
# We do that before any conversion that would lead to [<text>] that
# should be parsed, like [source] or [verse]
# [ and ]  will be eventually escaped as ++[++ and ++]++ but we tentatively
# replace them by   and  respectively to avoid collisions with
# "no formatting" opening or closing tags that are converted to ++.
# NOTE: I'm not sure if this reasoning is still valid after changing
# $[[ and ]]$$ to ++[++ and ++]++. ~JJ
/[]/ !{
	s/\[//g
	s/]//g
}
# Prevent expansion of an include macro inside an AsciiDoc Delimited block.
/[]/ {
	s/^include::/\\&/
}
# Get rid of the Code blocks, converted to Listing blocks: skip parsing
# their content.
// {
	\.</code>. {
		s///
		s@</code>@----@
		b print
	}
	\.</code>. !b print
}
	
// {
	\.</file>. {
		s///
		s@</file>@----@
		b print
	}
	\.</file>. !b print
}
# HTML comments. These comments are provided by the html comment plug-in
# for DokuWiki, see https://www.dokuwiki.org/plugin:htmlcomment
/ *<!--.*-->/ {
	s@ *\(<!--.*-->\)@// \1@
	b print
}
# To avoid a collision with "emphasized" whose marks are // in Dokuwiki,
# we will tentatively replace // with U+17 .
s@http://@http:@g
s@https://@https:@g
s@ftp://@ftp:@g
s@ftps://@ftps:@g
#
# Ruler
# =====
/^-----*/ {
	s/^-----*/'''\n/
	b print
}
#
# Mark keywords
# =============
# Mark sequences that have a special meaning in DokuWiki syntax.
s:{{:&:g                  # start of media link
s:}}:&:g                  # end of media link
s:\*\*:&:g                # bold
s://:&:g                  # italic
s:__:&:g                  # underline
s:'':&:g                  #Â mono-spaced
s:\(^\|[^']\)':\1':g    # single quote
s:":&:g                   # double quote
s:<:&:g                   # first character of HTML-like tag, email address delimiter
s:((:&:g                  # start of footnote
s:)):&:g                  # end of footnote
s:---:&:g                 # em-space
s:\(^\|[^-]\)--:\1--:g  # en-space (in middle/end of line)
s:([cr]):&:g              # (c), (r)
s:(tm):&:g                # (tm)

# Remove special meaning inside <nowiki> ... </nowiki> and %% ... %%.
:unescape
// {
	s/\([^]*\)/\1/
	s/\([^]*\)/\1[[/
	s/\([^]*\)/\1]]/
	t unescape
}
#
# Links
# =====
# In case someone asks... No we don't check that the URI be well formed.
#
# We convert them before the tables, because in DokuWiki syntax they can
# include a "|" that would otherwise be confused with a cell boundary.
#
# External links
# ==============
# Remove the space(s) that could precede the vertical bar or follow [[ in
# Dokuwiki syntax.
# e.g. [[  http://slint.fr  | Slint website]] becomes:
#      http://slint.fr[Slint website]
s/ *\([hf]t\{1,2\}ps\?:[^| ]*\) *| *\([^]*\)/\1[\2]/g
# Convert e.g. [[http://slint.fr]] to http://slint.fr
s/ *\([hf]t\{1,2\}ps\?:[^]*\)/\1/g
#
# Email addresses
# ===============
/ *[^@?| ]\+@[^@?| ]\+\.[[:alpha:]]\{2,\}\(?[^|]*\)\?\(|[^]*\)\?/ {
	# Convert [[<email> | <title>]] to mailto:<email>[<title>].
	s/ *\(mailto:\)\?\([^@?| ]\+@[^@?| ]\+\.[[:alpha:]]\{2,\}\) *| *\([^]*\)/mailto:\2[\3]/g
	# Convert [[<email>?subject=<subject> | <title>]] to mailto:<email>["<title>", "<subject>"].
	# Note: This needs attribute linkattrs to be set.
	s/ *\(mailto:\)\?\([^@?| ]\+@[^@?| ]\+\.[[:alpha:]]\{2,\}\)?subject=\([^|&]*\) *| *\([^]*\)/mailto:\2["\4", "\3"]/g
	# Convert [[<email>]] to mailto:<email>[].
	s/ *\(mailto:\)\?\([^@?| ]\+@[^@?| ]\+\.[[:alpha:]]\{2,\}\) */mailto:\2[]/g
	# Convert [[<email>?subject=<subject>]] to mailto:<email>[, "<subject>"].
	# Note: This needs attribute linkattrs to be set.
	s/ *\(mailto:\)\?\([^@?| ]\+@[^@?| ]\+\.[[:alpha:]]\{2,\}\)?subject=\([^|&]*\) */mailto:\2[, "\3"]/g
}
#
# Internal links
# ==============
# These are links of which the target is on the server that runs DokuWiki.
#
/[^|]*\(|[^]\+\)\?/ {
	# Remove blank titles.
	s@\([^|> ]\+\)| *@\1@g
	# Replace ":" in target (but not anchor) with "/".
	:interlink
	s@\\([^:#|>]*\):\([^|>]*\)\(|[^]\+\)\?@\1/\2\3@
	t interlink
	# Prepend "/" to the target with a namespace that does not start with
	# "/" or ".".
	s@\ *\([^/.|>]\{2,\}/[^|>]*\)\(|[^]\+\)\?@/\1\2@g
	# Remove useless prefixes "." and "./" in the target.
	s@\ *\./\?\([^.|>][^|>]*\)\(|[^]\+\)\?@\1\2@g
	# Replace ".." with "../" at the beginning of the target.
	s@\ *\.\.\([^/.|>][^|>]*\)\(|[^]\+\)\?@../\1\2@g

	# Links with title
	/[^|]*|[^]\+/ {
		# Replace [[#ANCHOR|TITLE]] with <<ANCHOR,TITLE>>.
		s@\ *#\([^|> ]*\) *| *\([^]\+\)@<<\1,\2>>@g
		# Replace [[<target>|<title>]] with xref:<target>#[<title>].
		s@\ *\([^#|> ]*\) *| *\([^]\+\)@xref:\1#[\2]@g
		# Replace [[<target>|<title>]] with xref:<target>[<title>].
		s@\ *\([^|> ]*\) *| *\([^]\+\)@xref:\1[\2]@g
	}
	# Links without title
	# Replace [[#ANCHOR]] with <<ANCHOR>>.
	s@\ *#\([^#>]\+\)@<<\1>>@g
	# Replace [[<target>]] with xref:<target>#[].
	s@\ *\([^#>]\+\)@xref:\1#[]@g
	# Replace [[<target>]] with link:<target>[].
	s@\ *\([^>]\+\)@xref:\1[]@g
}
# Media
# =====
# DokuWiki's links to media parsing is done in the script 
# dokuwiki/inc/parser/handler.php, function Doku_Handler_Parse_Media($match).
# AsciiDoc's link images syntax is stated in
# http://www.methods.co.nz/asciidoc/userguide.html#_inline_macros
# under 21.1.4 images.
# DokuWiki syntax:
# {{ <source>[?]<linking>&<width>[x<height>]] [| <title>] }}
# To set only height, set width to 0.
# Alignment left|center|right is done inserting a white space after
# {{ and/or before }}
# <linking> can be nolink|direct|linkonly|details
# details: implicit default value, starts detail.php that displays metadata
# linkonly: just an URL to the image file, image not displayed
# nolinks: no link to the image file is provided
# direct: image displayed and link to the image file provided
# AsciiDoc syntax:
# image:<target>[<attributes>]
# where <attributes> is a comma separated list
# an alt text should go first in the attributes' list. Other attributes
# needed for conversion:
# height=<number>
# width=<number>
# align="left|center|right"
# link="link to the image file"
# Conversion of DokuWiki's <linking> command values
# linkonly: treat as an ordinary link
# nolink: default for AsciiDoc
# direct: AsciiDoc's "link" attribute
# details: treated as default
#
# Issue: we can't include images stored elsewhere than in the <target>
# of AsciiDoc's image macro, that is relative to the URL given as argument
# of the "-a imagesdir=" AsciiDoc command line. This break links to images
# stored elsewhere.
#
# Note: DokuWiki syntax {{...}} is not used only for images, but for any files
# stored in media library! Thus we have to detect media type, based on file
# extension, and use appropriate AsciiDoc macro.
#
:media
/{{[^}]*}}/ {
	# Alignment
	# In DokuWiki syntax the alignment is computed from spacing:
	# _after {{ and before | if there is a caption
	# _after {{ and before }} if there is no caption.
	# Oh, well....
	# 
	# We remove aligning spaces, and spaces before }}
	# We also isolate the pattern {{..}} that we are processing
	//! s@{{  *\([^|} ]*\)  *\(|[^}]*\)\? *}}@\1["\2",align="center"]@
	//! s@{{\([^|} ]*\)  *\(|[^}]*\)\? *}}@\1["\2",align="left"]@
	//! s@{{  *\([^|} ]*\)\(|[^}]*\)\? *}}@\1["\2",float="right"]@
	//! s@{{\([^|} ]*\)\(|[^}]*\)\? *}}@\1["\2"]@
	# Remove "|" from alt text.
	s@\([^[]*\["\)|\([^]\+\)@\1\2@
	# linking
	# Replace ":" (namespace separator) in links with "/", except external
	# media files (containing "//" (^W).
	/[^]*/ {
		:imglink
		s@\([^[:]*\):\([^[]*\[[^]]*\]\)@\1/\2@
		t imglink
	}
	# Handle image link
	#
	# Example:
	# 0. [[n:m:start|{{n:img.png|alt}}]]
	# 1. [[...]] is processed by the link patterns:
	#    xref:/n/m/start#[{{n:img.png|alt}}]
	# 2. {{...}} is preprocessed by the patterns above into:
	#    xref:/n/m/start#[^]n/img.png["alt"]^]]
	# 3. the patterns below this comment converts it into:
	#    ^]/n/img.png["alt",link="/n/m/start"]^]
	# 4. and next patterns finally outputs:
	#    image::/n/img.png["alt",link="/n/m/start"]
	/[^ ]*\[[^]*\]/ {
		s@\([^ ]*[^[ ]*\)\[\([^]]*\)\]\]@\2,link="\1"]@
		s@xref:\([^[ ]*\)#\[\([^]]*\)\]\]@\2,link="DKIMAGES\1"]@
		s@xref:\([^[ ]*\)\[\([^]]*\)\]\]@\2,link="DKIMAGES\1"]@
	}
	/.*direct.*/ {
		s@\(.*\)?[^]]*@&,link="DKIMAGES\1"@
	}
	/[^[]*linkonly.*/ {
		s@\([^[]*\)\(?[^]*\)@\1@
		s@\([^[]*\)linkonly@\1@
	}
	# Dimensions
	/[^[]*[&?]0x[[:digit:]]\+[^]*/ {
		s@[^[]*[&?]0x\([[:digit:]]\+\)[^]]*@&,height="\1"@
		s@\([^[]*[&?]\)0x[[:digit:]]\+@\1@
	}
	/[^[]*[&?][[:digit:]]\+x[[:digit:]]\+[^]*/ {
		s@[^[]*[&?]\([[:digit:]]\+\)x\([[:digit:]]\+\)[^]]*@&,width="\1",height="\2"@
		s@\([^[]*[&?]\)[[:digit:]]\+x[[:digit:]]\+@\1@
	}
	/[^[]*[&?][^x=[]*[[:digit:]]\+[^]*/ {
		s@[^[]*[&?][^x[:digit:][]*\([[:digit:]]\+\)[^]]*@&,width="\1"@
	}
	# Image
	/[^?[]*IMAGE_FILE_PATT[?[][^]*/I {
		# remove empty alt text
		s/\([^]*\)\("",\?\)/\1/g
		# Use block image if there's nothing else on the line,
		/^ *[^]\+ */ {
			s@\([^?[]*\)[?]*[^[]*\(\[[^]*\)@\nimage::\1\2@
		}
		# otherwise use inline image.
		# XXX: align is ignored for inline images!
		/^ *[^]\+ */ !{
			s@ \?\([^?[]*\)[?]*[^[]*\(\[[^]*\) \?@ image:\1\2 @
		}
	}
	# Other media
	/[^?[]*IMAGE_FILE_PATT[?[][^]*/I !{
		# If title is empty, use file name (not complete path) as the title.
		/[^[]\+\[""[^]*/ {
			s@\([^/ ]\+\)\[""\([^]]*\]\)@\1["\1"\2@
		}
		s@/\?\([^?[]\+\)[?]*[^[]*\["\([^"]*\)"[^]]*\]@link:{imagesdir}/\1[\2]@
	}
	t media
}
:endlinks
#
# Email addresses
# ===============
s/<\([^@>]\{1,30\}@[^>]\{1,30\}[.][[:alpha:]]\{2,\}\)>/\1/

s//[[/g
s//]]/g
#
# Tables
# ======
# In DokuWiki a table cell begins with "^" (to be formatted as a heading)
# or "|" (default formatting) and ends with one or more consecutive
# "|" or "^". The number of trailing "|" or "^" indicates the number of
# columns that the cell on their left spans on its right, for instance ^^^
# means that the cell spans over three columns and that the one to the
# right on the same row (if any) should be formatted as a heading. 
# Here is an example of DokuWiki formatting of table cells, followed by
# its conversion to AsciiDoc syntax.
# ^  This right aligned heading spans over 3 columns on its right|||
# 3+>h|This right aligned heading span over 3 columns on its right|
# The kind (| or ^) of the rightmost cell boundary in a row doesn't matter
# and in AsciiDoc the rightmost cell doesn't have a right boundary in "psv"
# (the default) table format.
# ^ will be converted to "h" as in "heading"
# | will not be converted (it is the default)
# > means align right, ^ align center, < align left 
# ^^^ becomes 3+
# We won't convert vertical (over rows) spanning: that would need to store
# the whole table in the pattern and/or hold space as the DokuWiki ":::"
# mark found alone in a cell indicates that it should span over the cell
# up, but in AsciiDoc the mark ".<number>" indicates that the cell spans
# over <number> cells down, so we would need to read and store <number>
# lines before making the conversion.
# We will make the conversion in following order:
# horizontal spanning, then alignment (>, ^ or <), then formatting (h or d)
// {
	# Inside a table, close it if we find a line that is not a table row.
	/^[|^[]/ !{
		s///
		s@[^]*@|====\n&@
		b closetbl
	}
}
/^[|^]/ {
	# Tentatively replace | and ^ by control characters if part of an
	# in-line text in a row that should not be formatted.
	:nc1
	/[^]*|/ {s/\([^]*\)|/\1/;t nc1}
	:nc2
	/[^]*^/ {s/\([^]*\)^/\1/;t nc2}
	# In a mix of | and ^ that makes a cell boundary, the rightmost one
	# supersedes the other ones to choose how to formatting the cell
	# on the left (not disclosed DokuWiki syntax feature that we mimic).
	:heading
	s/\^\(|*\)|/|\1|/
	s/|\(\^*\)^/^\1^/
	t heading
	:default
	t default
	# At most one "|" or "^" should begin a row
	s/^||*/|/
	s/^^^*/^/
	# Suppress spaces after the last delimiter, that will be "|"
	s/\([|^]\+\) */\1/
	s/\([|^]\+\)\( *\)/\1\2/
	s/\^/|/
	:vertbar
	s/\^\([|]\+\)/|\1/
	t vertbar
	s/\^/|/
	s/^//
	# Here begins the loop inside which we process each cell.
	:nextcell
	# cells spanning over at most 9 columns.  I hope it's enough.
	s/\([|^][^|^]\+\)|||||||||/9+\1|/
	s/\([|^][^|^]\+\)||||||||/8+\1|/
	s/\([|^][^|^]\+\)|||||||/7+\1|/
	s/\([|^][^|^]\+\)||||||/6+\1|/
	s/\([|^][^|^]\+\)|||||/5+\1|/
	s/\([|^][^|^]\+\)||||/4+\1|/
	s/\([|^][^|^]\+\)|||/3+\1|/
	s/\([|^][^|^]\+\)||/2+\1|/     	
	s/\([|^][^|^]\+\)^^^^^^^^^/9+\1^/
	s/\([|^][^|^]\+\)^^^^^^^^/8+\1^/
	s/\([|^][^|^]\+\)^^^^^^^/7+\1^/
	s/\([|^][^|^]\+\)^^^^^^/6+\1^/
	s/\([|^][^|^]\+\)^^^^^/5+\1^/
	s/\([|^][^|^]\+\)^^^^/4+\1^/
	s/\([|^][^|^]\+\)^^^/3+\1^/
	s/\([|^][^|^]\+\)^^/2+\1^/
	# Alignments: left, then right, then center. We mark each pattern that
	# we process preceding it with U+16  to avoid processing the
	# same one twice.   
	# We tentatively use U+11  for "align center" as in DokuWiki "^"
	# denotes a cell boundary.
	# "left" (<) is the default in AsciiDoc so we omit it. Also ensure that
	# there's at least one space after "|" to make it more readable.
	s/\([|^]\) \?\([^|^ ][^|^]*[|^]\)/\1 \2/  # left
	s/\([|^]  [^|^]*[^|^ ] \?[|^]\)/>\1/  # right
	s/\([|^]  [^|^]*   *[|^]\)/\1/  # center
	# Format the cell as a header, case occurring.
	s/\^/h|/
	# Be ready to process the next cell on the right.
	s/\(|[^|^]*\)\([|^]\)/\1\2/
	# Process the next cell if any.
	/|/ !b nextcell
	# All cells of the row have now been processed.
	# Remove the last "already processed" mark.
	s///g
	# Remove the rightmost cell boundary.
	s/[^|^]//
	# Restore the "align center" mark.
	s//\^/g
	# Insert a space before each sequence of AsciiDoc's cell attributes
	s/\([[:digit:]]+\)\?[<>^]h\?|/ &/g
	# Remove the last cell separator, and case occurring the " h" that
	# precedes it.
	s/ h|//
	s/|//
	// !{
		# Mark the beginning of the table.
		s/^/[options="autowidth"]\n|====\n/
		s/$//
	}
}
:closetbl
# Headings
# ========
#
# We insert a blank line before the heading if there was none.
# Bear in mind that the heading can directly follow an AsciiDoc mark 
# "end of table" just converted like this:
# |====\n====== Chapter Navigation ======
# "======" is the maximum (header level 1) but DokuWiki accepts "======="
# Also, there should be the same number of equal signs on both sides of
# the heading, but the DokuWiki parser is lenient. The patterns are
# adapted to mimic this leniency.
/^\(|====\)\?\n*=======\([^=][^=]*\)=\{2,\}/ {
	s/^\(|====\n\)=======\([^=][^=]*\)=\{2,\}/\1= \2\n/
	s/^=======\([^=][^=]*\)=\{2,\}/= \1\n/
	/.*n.*/ !{
		/^|====/ !s/^/\n/
		/^|====/ s/\n/&\n/
	}
}
/^\(|====\)\?\n*======\([^=][^=]*\)=\{2,\}/ {
	s/^\(|====\n\)======\([^=][^=]*\)=\{2,\}/\1= \2\n/
	s/^======\([^=][^=]*\)=\{2,\}/= \1\n/
	/.*n.*/ !{
		/^|====/ !s/^/\n/
		/^|====/ s/\n/&\n/
	}
}
/^\(|====\)\?\n*=====\([^=][^=]*\)=\{2,\}/ {
	s/^\(|====\n\)=====\([^=][^=]*\)=\{2,\}/\1== \2\n/
	s/^=====\([^=][^=]*\)=\{2,\}/== \1\n/
	/.*n.*/ !{
		/^|====/ !s/^/\n/
		/^|====/ s/\n/&\n/
	}
}
/^\(|====\)\?\n*====\([^=][^=]*\)=\{2,\}/ {
	s/^\(|====\n\)====\([^=][^=]*\)=\{2,\}/\1=== \2\n/
	s/^====\([^=][^=]*\)=\{2,\}/=== \1\n/
	/.*n.*/ !{
		/^|====/ !s/^/\n/
		/^|====/ s/\n/&\n/
	}
}
/^\(|====\)\?\n*===\([^=][^=]*\)=\{2,\}/ {
	s/^\(|===\n\)====\([^=][^=]*\)=\{2,\}/\1==== \2\n/
	s/^===\([^=][^=]*\)=\{2,\}/==== \1\n/
	/.*n.*/ !{
		/^|====/ !s/^/\n/
		/^|====/ s/\n/&\n/
	}
}
/^\(|====\)\?\n*==\([^=][^=]*\)=\{2,\}/ {
	s/^\(|==\n\)====\([^=][^=]*\)=\{2,\}/\1===== \2\n/
	s/^==\([^=][^=]*\)=\{2,\}/===== \1\n/
	/.*n.*/ !{
		/^|====/ !s/^/\n/
		/^|====/ s/\n/&\n/
	}
}
#
# Admonitions
# ===========
s/^<note>/[NOTE]\n====/
s/^<note important>/[IMPORTANT]\n====/
s/^<note tip>/[TIP]\n====/
s/^<note warning>/[WARNING]\n====/
\@^</note>@ {
	s:^</note> +: +\n====:
	s:^</note>:====:
}
# In AsciiDoc a line beginning with at least a single space begins a
# literal paragraph.
/^ +/ b continue
/\n +/ b continue
s/^ \([^ ]*\)/\1/g
s/\n \([^ ]*\)/\n\1/g
#
:continue
#
# Line breaks inside tables
# =========================
# The line breaks outside tables have been processed in @part 1@.
# In case of consecutive line breaks keep only the first.
:breaks
s/ *[\][\]  *\([\][\]  *\)/\1/
s/ *[\][\]  */ +\n/
t breaks
#
# We will skip the following substitutions inside %% ... %% or inside
# <nowiki>  ... </nowiki>
#
# footnotes
# =========
/((/ {
	s/))//g
	s/((\([^]\+\)/footnote:[\1]/g
	s//))/g
}
# Typographic legal symbols
# =========================
s/(c)/(C)/g
s/(r)/(R)/g
s/(tm)/(TM)/g

# em dash
# ======
s/---/â€”/g  # U+2014
# en dash
# =======
s/--/â€“/g  # U+2013
# When processing following items we need to write non greedy BREs, thus
# negate the closing mark inside the BRE. To ease that, we tentatively
# replace closing marks made of several characters by a single character.
#
# underlined
# ==========
/__/ {
	s/__//g
	s/\([^]\+\)/[underline]#\1#/g
	s//__/g
}
#
# monospaced
# ==========
/''/ {
	s/''//g
	s/\([^]\+\)/\1/g
	s//''/g
}
#
# strike through
# ==============
/<del>/ {
	s:</del>::g
	s:<del>\([^]\+\):[line-through]#\1#:g  # FIXME: use ## if spaces
	s::</del>:g
}
#
# superscript
# ===========
/<sup>/ {
	s:</sup>::g
	s:<sup>\([^]\+\):^\1^:g
	s::</sup>:g
}
#
# subscript
# =========
/<sub>/ {
	s:</sub>::g
	s:<sub>\([^]\+\):~\1~:g
	s::</sub>:g
}
#
# emphasized
# ==========
# We previously substituted  to // in URLs
\@//@ {
	s@//@@g
	s@\([^]\+\)@__\1__@g
	s@@//@g
}
#
# Single quotation marks
# ======================
/'/ {
	# We allow a single quotation mark to be included inside a word part of a
	# single quoted set of words. 
	s/\([[:alpha:]]\)\('[[:alpha:]]\)/\1\2/g
	s/'//g
	s/\(^\|[ !-.:;_)]\)\([^]\+\)\([ !-.:;_)]\)/\1\2\3/g
	s//'/g
}
#
# double quotation marks
# ======================
/"/ {
	s/"//g
	s/\(^\|[ !-.:;_)]\)\([^]\+\)\([ !-.:;_)]\)/\1\2\3/g
	s//"/g
}
#
# We need to escape opening curly brackets as else a line that contains
# {word} will be removed from AsciiDoc's output unless <word> be a defined
# attribute name, cf:
# http://www.methods.co.nz/asciidoc/userguide.html#_simple_attributes_references
s/{/\{/g
#
# In an AsciiDoc "psv" table a "|" is escaped lake this: "\|" 
s//\\|/g
s//^/g
s/@@@@//
s/$\$/+++$$+++/g
#
#
# Replace unconstrained marks with constrained
# ============================================
# **bold** to *bold*
/\*\*[^*]*\*\*/ {
	s/\(^\|[^[:alnum:]:;}_*]\)\*\*\(\?[^*[:blank:]]\)\([^*]*[^*[:blank:]]\)\?\*\*\(\?[^*[:alnum:]]\)/\1*\2\3*\4/g
}
# __italic__ to _italic_
/__[^_]*__/ {
	s/\(^\|[^[:alnum:]:;}_]\)__\(\?[^_[:blank:]]\)\([^_]*[^_[:blank:]]\)\?__\(\?[^_[:alnum:]]\)/\1_\2\3_\4/g
}
# ``mono-spaced`` to `mono-spaced`
/[^]*/ {
	s/\(^\|[^[:alnum:]:;}_]\)\(\?[[:graph:]]\)\([^]*[[:graph:]]\)\?\(\?[^[:alnum:]]\)/\1\2\3\4/g
}
#
:print
# Finish to convert the lists, revert tentative substitutions. 
s:://:g
s//++[++/g
s//++]++/g
s//++/g
s//++/g
s//++/g
s//``/g
s//LS_QUOTE/g
s//RS_QUOTE/g
s//LD_QUOTE/g
s//RD_QUOTE/g
# Restore the [source,<language>] and [verse] patterns.
s//[[/g
s//]]/g
s///g
s//`/g
s///g
h
x
# remove the indicator that says: "previous line included /^+$/"
s///g
# Leave only the baton in the hold space
s/.*//
# Only , remain in the baton
x
# Remove all trailing spaces
s/\([[:graph:]]*\) */\1/
# Remove the baton from the line before printing it.
s/.*//
p
#
#@EOF@ -----------------------------------------------------------------
#
# Support
# =======
#
# The most recent information about convtags and the current release are
# available at http://slint.fr/misc/convtags
#
# Please address all bug reports, questions and proposed enhancements to
# me: didier [at] slint [dot] fr
# 
# To make sure that your email be answered, please include the word
# "convtags" in the subject line.
#
# If possible attach the file to be converted and indicate which command
# and what settings you used for the conversion, so that I can try to
# reproduce the bug. And make sure that the input file is of the relevant
# type for the intended conversion, that else will certainly fail.
# It happened to me several times ;)
#
# Also check that you are using the current release of this program,
# comparing its version displayed typing "convtags" with the most recent
# one indicated in http://slint.fr/misc/convtags/ChangeLog
#
# Didier Spaier, Paris 04/10/2015
#
# End of support
